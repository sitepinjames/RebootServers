pipeline {
    agent any
    
    parameters {
        choice(name: 'Platform', choices: ['Linux', 'Windows', 'All'], description: 'Select instance type to manage')
    }

    stages {
        stage('Setup AWS CLI') {
            steps {
                script {
                    withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: '4911f03a-73f3-4055-9fff-e4fe316422f6']]) {
                        sh 'aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID'
                        sh 'aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY'
                        sh 'aws configure set region us-east-1'
                    }
                }
            }
        }
        stage('Stop Linux Instances') {
            when {
                expression { params.Platform == 'Linux' || params.Platform == 'All' }
            }
            steps {
                script {
                    echo 'Stopping Linux Instances...'
                    // Add logic for stopping Linux instances
                    def linuxInstances = [
                        'i-06a6e3bedfc7e489c',
                        'i-0cf6387c11543434b',
                        'i-0fd5ac3199e8d90c6',
                        'i-0fe398d756a7674d5',
                        'i-07627036355757a91',
                        'i-0761d61e6bde41800',
                        'i-0eb696d2e783b308d',
                        'i-046fd7ae38db5cc02',
                        'i-0bfc2f1385aa6359a',
                        'i-0d95ef8470e999593',
                        'i-0b00f288853c45601',
                        'i-0cd49ce4c628a79da',
                        'i-01b219308b776d8c9',
                        'i-09e022c9f9922f17e',
                        'i-08e44cbe5f2726e69',
                        'i-041559ad9860a0a66',
                        'i-014bd77e3a204255d',
                        'i-09cf5898b393e8ef2',
                        'i-0a126c66fc4d2c23d',
                        'i-0592feca136527713',
                        'i-0915e6a70c88170bb',
                        'i-078874a30cf0f048e',
                        'i-0f4871c3881d29215',
                        'i-026b0179d602903cd',
                        'i-07cb8ba0fdffbbb8b',
                        'i-0933fe6d03daae3e3',
                        'i-02ef0d40468629edc',
                        'i-059de1e7893df8270',
                        'i-0d4c882bd70f975ee',
                        'i-03da1f9ed98ac198a',
                        'i-030440635b4b39eed',
                        'i-017d38ae484b7971f',
                        'i-08bf7a06fd200a084',
                        'i-0cdea2ed843caaddb',
                        'i-07741514f61487741'
                    ] 
                    // Function to check if instances are stopped
                    def areInstancesStopped = { ids ->
                        def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                        return state.split('\n').every { it == 'stopped' }
                    }
                     // Function to list already stopped instances
                    def listAlreadyStopped = { ids ->
                        def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                        echo "Instance states: for ${state}"
                        return ids.findAll { !state.split('\n').contains('running') }
                    }
                    // Function to wait until all specified instances are stopped
                    def waitForInstancesToStop = { ids, maxWaitTime = 600, checkInterval = 15 ->
                        def waited = 0
                        while (waited < maxWaitTime) {
                            def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                            def states = state.split("\\s+")
                            echo "Instance states: ${states}"
                            // Check each state individually and log
                            def allStopped = true
                            states.each { instanceState ->
                                echo "Instance state: ${instanceState}"
                                if (instanceState != 'stopped') {
                                    allStopped = false
                                }
                            }
                            if (allStopped) {
                                echo "All instances are now stopped."
                                return true
                            } else {
                                echo "Not all instances are stopped yet."
                            }
                            sleep(checkInterval) // Wait before checking again
                            waited += checkInterval
                        }
                        error "Timeout: Not all instances are stopped after ${maxWaitTime} seconds."
                    }       
                    // Define Linux instance IDs
                    def stoppedLinuxInstances = areInstancesStopped(linuxInstances)
                    def runningLinuxInstances = linuxInstances - stoppedLinuxInstances

                    if (runningLinuxInstances) {
                        sh "aws ec2 stop-instances --instance-ids ${runningLinuxInstances.join(' ')}"
                        waitForInstancesToStop(runningLinuxInstances,600,10)
                    }

                    if (stoppedLinuxInstances) {
                        echo "The following Linux instances were already stopped: ${stoppedLinuxInstances.join(', ')}"
                    }
                }
            }
        }
        stage('Stop Pega Admin Servers') {
            when {
                expression { params.Platform == 'Linux' || params.Platform == 'All' }
            }
            steps {
                script {
                    echo 'Stopping Pega Admin Servers...'
                    def pegaStopAdminservers = [
                    ['i-0044d39fa602f4149', 'i-004ca4f23ea69fbd0'], // Pega Admin for Dev (2 instances)
                    ['i-0d33dcd0d79ac69ad', 'i-0b71fd6c038e422f3'], // Pega Admin for Test (2 instances)
                    ['i-03d6e2a434ca5b1b6', 'i-05fa9b4e9020ad80b', 'i-0731efcda09633997'], // Pega Admin for Impl (3 instances)
                    ['i-02565e5f7320ba59a', 'i-0b4c64b4080e80d7c', 'i-032c68f31da216cec']  // Pega Admin for Pro (3 instances)
                    ]
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                     // Function to check if instances are running
                    def areInstancesRunning = { ids ->
                        def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                        return state.split('\n').every { it == 'running' }
                    }
                    // Function to check if instances are stopped
                    def areInstancesStopped = { ids ->
                        def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                        return state.split('\n').every { it == 'stopped' }
                    }
                    // Function to list already stopped instances
                    def listAlreadyStopped = { ids ->
                        def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                        return ids.findAll { !state.split('\n').contains('running') }
                    }
                    // Function to wait until all specified instances are stopped
                    // def waitForInstancesToStop = { ids, maxWaitTime = 600, checkInterval = 10->
                    //     def waited = 0
                    //     while (waited < maxWaitTime) {
                    //         if (areInstancesStopped(ids)) {
                    //             return true
                    //         }
                    //         sleep(checkInterval) // Wait before checking again
                    //         waited += checkInterval
                    //     }
                    //     error "Timeout: Not all instances are stopped after ${maxWaitTime} seconds."
                    // }   
                    
                    // Function to wait until all specified instances are stopped
                    def waitForInstancesToStop = { ids, maxWaitTime = 600, checkInterval = 15 ->
                        def waited = 0
                        while (waited < maxWaitTime) {
                            def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                            def states = state.split("\\s+")
                            echo "Instance states: ${states}"
                            // Check each state individually and log
                            def allStopped = true
                            states.each { instanceState ->
                                echo "Instance state: ${instanceState}"
                                if (instanceState != 'stopped') {
                                    allStopped = false
                                }
                            }
                            if (allStopped) {
                                echo "All instances are now stopped."
                                return true
                            } else {
                                echo "Not all instances are stopped yet."
                            }
                            sleep(checkInterval) // Wait before checking again
                            waited += checkInterval
                        }
                        error "Timeout: Not all instances are stopped after ${maxWaitTime} seconds."
                    }       
                    // Stop the first instances of each environment simultaneously
                    def firstInstancesToStop = pegaStopAdminservers.collect { it[0] } // Get first instance IDs
                    def firstInstancesRunning = firstInstancesToStop.findAll { areInstancesRunning([it]) } // Check if they are running
                    def firstInstancesStopped = firstInstancesToStop - firstInstancesRunning // Determine already stopped instances
                    if (firstInstancesRunning) {
                        echo "Stopping the following Pega Admin instances: ${firstInstancesRunning.join(', ')}"
                        sh "aws ec2 stop-instances --instance-ids ${firstInstancesRunning.join(' ')}"
                
                        // Wait for all first instances to stop
                        waitForInstancesToStop(firstInstancesRunning,600,10)
                    }
                    // Report which first instances were already stopped
                    if (firstInstancesStopped) {
                        echo "The following first Pega Admin instances were already stopped: ${firstInstancesStopped.join(', ')}"
                    } 
                    sleep(7)
                    // Stop the second instances of each environment simultaneously, if they exist
                    def secondInstancesToStop = pegaStopAdminservers.collect { it.size() > 1 ? it[1] : null }.findAll { it != null }
                    def secondInstancesRunning = secondInstancesToStop.findAll { areInstancesRunning([it]) }
                    def secondInstancesStopped = secondInstancesToStop - secondInstancesRunning // Determine already stopped instances

                    if (secondInstancesRunning) {
                        echo "Stopping the following second Pega Admin instances: ${secondInstancesRunning.join(', ')}"
                        sh "aws ec2 stop-instances --instance-ids ${secondInstancesRunning.join(' ')}"
                
                        // Wait for all second instances to stop
                        waitForInstancesToStop(secondInstancesRunning,600,10)
                    }
                    // Report which second instances were already stopped
                    if (secondInstancesStopped) {
                        echo "The following second Pega Admin instances were already stopped: ${secondInstancesStopped.join(', ')}"
                    }
                    sleep(9)
                    // Stop the third instances of each environment simultaneously, if they exist
                    def thirdInstancesToStop = pegaStopAdminservers.collect { it.size() > 2 ? it[2] : null }.findAll { it != null }
                    def thirdInstancesRunning = thirdInstancesToStop.findAll { areInstancesRunning([it]) }
                    def thirdInstancesStopped = thirdInstancesToStop - thirdInstancesRunning // Determine already stopped instances
                    if (thirdInstancesRunning) {
                        echo "Stopping the following third Pega Admin instances: ${thirdInstancesRunning.join(', ')}"
                        sh "aws ec2 stop-instances --instance-ids ${thirdInstancesRunning.join(' ')}"
                
                        // Wait for all third instances to stop
                        waitForInstancesToStop(thirdInstancesRunning,600,10)
                    }
                    // Report which third instances were already stopped
                    if (thirdInstancesStopped) {
                        echo "The following third Pega Admin instances were already stopped: ${thirdInstancesStopped.join(', ')}"
                    } 
                 }
            }
        }

        stage('Stop Windows Instances') {
            when {
                expression { params.Platform == 'Windows' || params.Platform == 'All' }
            }
            steps {
                script {
                    echo 'Stopping Windows Instances...'
                    // Add logic for stopping Windows instances
                    def windowsInstances = [
                        'i-0915fb70e408f60e4',
                        'i-06c8e9966e87a5935',
                        'i-0b71f0bd670834b9d',
                        'i-0ca21ef9a2270d55d',
                        'i-0df9a19ca3538cda8',
                        'i-068a4bc409cd40e06',
                        'i-01616e32d7f17fe1b',
                        'i-09813645748b96018',
                        'i-0c0e62068149e356b',
                        'i-0f8f5e0073f5c4f4e',
                        'i-0461a1eac6cc16150',
                        'i-0239bae9abfc82d9f',
                        'i-00385a16def4a33da',
                        'i-01fe7afc21afed5af',
                        'i-05c6b1925a396feea'] // Define Windows instance IDs
                        
                    // Function to check if instances are stopped
                    def areInstancesStopped = { ids ->
                        def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                        return state.split('\n').every { it == 'stopped' }
                    }
                    def iseachInstanceStopped = { ids ->
                        def state = sh(script: "aws ec2 describe-instances --instance-ids ${instanceId} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                        return state.split('\n').every { it == 'stopped' }
                    }
                     // Function to list already stopped instances
                    def listAlreadyStopped = { ids ->
                        def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                        return ids.findAll { !state.split('\n').contains('running') }
                    }
                    // Function to wait until all specified instances are stopped
                    def waitForInstancesToStop = { ids, maxWaitTime = 600, checkInterval = 15 ->
                        def waited = 0
                        while (waited < maxWaitTime) {
                            def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                            def states = state.split("\\s+")
                            echo "Instance states: ${states}"
                            
                            // Check each state individually and log
                            def allStopped = true
                            states.each { instanceState ->
                                echo "Instance state: ${instanceState}"
                                if (instanceState != 'stopped') {
                                    allStopped = false
                                }
                            }
                            if (allStopped) {
                                echo "All instances are now stopped."
                                return true
                            } else {
                                echo "Not all instances are stopped yet."
                            }
                            sleep(checkInterval) // Wait before checking again
                            waited += checkInterval
                        }
                        error "Timeout: Not all instances are stopped after ${maxWaitTime} seconds."
                    }       
                    //def stoppedWindowsInstances = listAlreadyStopped(windowsInstances)
                    def stoppedWindowsInstances = areInstancesStopped(windowsInstances)
                    def runningWindowsInstances = windowsInstances - stoppedWindowsInstances

                    if (runningWindowsInstances) {
                        sh "aws ec2 stop-instances --instance-ids ${runningWindowsInstances.join(' ')}"
                        waitForInstancesToStop(runningWindowsInstances,600,15)
                    }

                    if (stoppedWindowsInstances) {
                        echo "The following Windows instances were already stopped: ${stoppedWindowsInstances.join(', ')}"
                    }
                }
            }
        }
        stage('Stop Database Servers') {
            when {
                expression { params.Platform == 'Linux' || params.Platform == 'All' }
            }
            steps {
                script {
                    echo 'Stopping Database Servers...'
                    def dbInstances = [
                        ['i-080290e8b4500dcf2'],                               // DB instances for Dev (1 instance)
                        ['i-0b302b30221fc0f01', 'i-010dcd0c49fdbbe16'],        // DB instances for Trn (2 instances)
                        ['i-07fe31a8f10646bd8', 'i-04151d48025065448']         // DB instances for Impl (2 instances)
                    ] // Define database instance IDs per environment
                    
                    // Function to check if instances are running
                    def areInstancesRunning = { ids ->
                        def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                        return state.split('\n').every { it == 'running' }
                    }
                    // Function to check if instances are stopped
                    def areInstancesStopped = { ids ->
                        def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                        return state.split('\n').every { it == 'stopped' }
                    }
                     // Function to list already stopped instances
                    def listAlreadyStopped = { ids ->
                        def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                        return ids.findAll { !state.split('\n').contains('running') }
                    }
                    // Function to wait until all specified instances are stopped
                    // def waitForInstancesToStop = { ids, maxWaitTime = 600, checkInterval = 15 ->
                    //     def waited = 0
                    //     while (waited < maxWaitTime) {
                    //         if (areInstancesStopped(ids)) {
                    //             return true
                    //         }
                    //         sleep(checkInterval) // Wait before checking again
                    //         waited += checkInterval
                    //     }
                    //     error "Timeout: Not all instances are stopped after ${maxWaitTime} seconds."
                    // }  
                    
                    // Function to wait until all specified instances are stopped
                    def waitForInstancesToStop = { ids, maxWaitTime = 600, checkInterval = 15 ->
                        def waited = 0
                        while (waited < maxWaitTime) {
                            def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                            def states = state.split("\\s+")
                            echo "Instance states: ${states}"
                            
                            // Check each state individually and log
                            def allStopped = true
                            states.each { instanceState ->
                                echo "Instance state: ${instanceState}"
                                if (instanceState != 'stopped') {
                                    allStopped = false
                                }
                            }
                            if (allStopped) {
                                echo "All instances are now stopped."
                                return true
                            } else {
                                echo "Not all instances are stopped yet."
                            }
                            sleep(checkInterval) // Wait before checking again
                            waited += checkInterval
                        }
                        error "Timeout: Not all instances are stopped after ${maxWaitTime} seconds."
                    }       
                     // Stop the first instances of each environment simultaneously
                    def firstInstancesToStop = dbInstances.collect { it[0] } // Collect the first instance from each environment
                    def firstInstancesRunning = firstInstancesToStop.findAll { areInstancesRunning([it]) } // Check if they are running
                    def firstInstancesStopped = firstInstancesToStop - firstInstancesRunning // Determine already stopped instances
                    if (firstInstancesRunning) {
                        echo "Stopping the following first Database instances: ${firstInstancesToStop.join(', ')}"
                        sh "aws ec2 stop-instances --instance-ids ${firstInstancesToStop.join(' ')}"
                
                        // Wait for all first instances to stop
                        waitForInstancesToStop(firstInstancesToStop,600,15)
                    }
                    // Report which first instances were already stopped
                    if (firstInstancesStopped) {
                        echo "The following first Database instances were already stopped: ${firstInstancesStopped.join(', ')}"
                    }
                    sleep (23)
                    // Stop the second instances of each environment if they exist
                    def secondInstancesToStop = dbInstances.collect { it.size() > 1 ? it[1] : null }.findAll { it != null }
                    def secondInstancesRunning = secondInstancesToStop.findAll { areInstancesRunning([it]) }
                    def secondInstancesStopped = secondInstancesToStop - secondInstancesRunning // Determine already stopped instances
                    if (secondInstancesRunning) {
                        echo "Stopping the following second Database instances: ${secondInstancesToStop.join(', ')}"
                        sh "aws ec2 stop-instances --instance-ids ${secondInstancesToStop.join(' ')}"
                
                        // Wait for all second instances to stop
                        waitForInstancesToStop(secondInstancesToStop,600,15)
                    }
                    // Report which second instances were already stopped
                    if (secondInstancesStopped) {
                        echo "The following second Database instances were already stopped: ${secondInstancesStopped.join(', ')}"
                    }
                }
            }
        }      
        stage('Confirm to proceed to start'){
            steps {
                script {
                    // Human intervention after confirming second instances
                        input(message: "Please press proceed if you want are ready to start the instances.")
                    }
                }
        }
        stage('Start Database Servers') {
            when {
                expression { params.Platform == 'Linux' || params.Platform == 'All' }
             }
             steps {
                script {
                    echo 'Starting Database Servers...'
                    def dbInstances = [
                        ['i-080290e8b4500dcf2'],                          // DB instances for Dev (1 instance)
                        ['i-0b302b30221fc0f01', 'i-010dcd0c49fdbbe16'], // DB instances for Trn (2 instances)
                        ['i-07fe31a8f10646bd8', 'i-04151d48025065448']  // DB instances for Impl (2 instances)
                    ] // Define database instance IDs per environment
                    // Function to check if instances are running
                    def areInstancesRunning = { ids ->
                        def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                    return state.split('\n').every { it == 'running' }
                    }
                    // Function to check if an instance is operational
                     def isInstanceOperational = { instanceId, maxWaitTime = 300, checkInterval = 15 ->
                        def waited = 0
                        while (waited < maxWaitTime) {
                            def status = sh(script: "aws ec2 describe-instance-status --instance-ids ${instanceId} --query 'InstanceStatuses[0].{InstanceState:InstanceState.Name,SystemStatus:SystemStatus.Status,InstanceStatus:InstanceStatus.Status}' --output json", returnStdout: true)
                            // Debug output to check status received
                            echo "Status for instance ${instanceId}: ${status}"
                            // Check if the status is empty
                            if (!status || status.trim() == 'null'){
                                echo "Instance ${instanceId} is still initializing or not available."
                            } else if (status && status != 'null') {
                                def instanceStatus = new groovy.json.JsonSlurper().parseText(status) // Use JsonSlurper for parsing
                                // Check if instance is running and both system and instance statuses are ok
                                if (instanceStatus && instanceStatus.InstanceState && instanceStatus.InstanceState == 'running' && instanceStatus.SystemStatus == 'ok' && instanceStatus.InstanceStatus == 'ok') {
                                    echo " expected states met"
                                    return true // Instance is operational
                                }
                            } 
                            sleep(checkInterval) // Wait before checking again
                            waited += checkInterval // Increment waited time
                        }
                        error "Timeout: Instance ${instanceId} is not operational after ${maxWaitTime} seconds."
                    }
                    // Function to wait until all specified instances are running
                    def waitForInstancesToStart = { ids, maxWaitTime = 600, checkInterval = 15 ->
                        def waited = 0
                        while (waited < maxWaitTime) {
                            def allOperational = true // Flag to check if all instances are operational
                            for (id in ids) {
                                if (!isInstanceOperational(id,300,15)) {
                                   allOperational = false // If any instance is not operational, set the flag to false
                                   echo "Instance ${instanceId} did not start successfully."
                                }
                            }
                            if (allOperational) {
                                return true // All instances are operational
                            }
                            sleep(checkInterval) // Wait before checking again
                             waited += checkInterval
                        }
                        error "Timeout: Not all instances are started after ${maxWaitTime} seconds."
                    }

                    // Start the first instances of each environment simultaneously
                    def firstInstancesToStart = dbInstances.collect { it[0] } // Collect the first instance IDs
                    if (firstInstancesToStart) {
                        echo "Starting the following first Database instances: ${firstInstancesToStart.join(', ')}"
                        sh "aws ec2 start-instances --instance-ids ${firstInstancesToStart.join(' ')}"
                
                        // Wait for all first instances to be fully operational
                        waitForInstancesToStart(firstInstancesToStart,600, 15)
                    }
                    sleep(24)
                    // Start the second instances of each environment if they exist
                    def secondInstancesToStart = dbInstances.collect { it.size() > 1 ? it[1] : null }.findAll { it != null }
                    if (secondInstancesToStart) {
                        echo "Starting the following second Database instances: ${secondInstancesToStart.join(', ')}"
                        sh "aws ec2 start-instances --instance-ids ${secondInstancesToStart.join(' ')}"

                        // Wait for all second instances to be fully operational
                        waitForInstancesToStart(secondInstancesToStart,600, 15)
                    }
                }
            }
        }
        stage('Sleep 15sec- before Pegastarts'){
            steps {
                script {
                    sleep(8)
                }
            }
        }
        stage('Start Pega Admin Servers') {
            when {
                expression { params.Platform == 'Linux' || params.Platform == 'All' }
             }
            steps {
                script {
                    echo 'Starting Pega Admin Servers...'
                    def pegaStartAdminservers = [
                        ['i-0d33dcd0d79ac69ad', 'i-0b71fd6c038e422f3'], // Pega Admin for Test (2 instances)
                        ['i-03d6e2a434ca5b1b6', 'i-05fa9b4e9020ad80b', 'i-0731efcda09633997'], // Pega Admin for Impl (3 instances)
                        ['i-02565e5f7320ba59a', 'i-0b4c64b4080e80d7c', 'i-032c68f31da216cec']  // Pega Admin for Pro (3 instances)
                    ]
                    // Function to check if instances are running
                    def areInstancesRunning = { ids ->
                        def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                    return state.split('\n').every { it == 'running' }
                    }
                    
                    // Function to check if an instance is operational
                    def isInstanceOperational = { instanceId, maxWaitTime = 300, checkInterval = 15 ->
                        def waited = 0
                        while (waited < maxWaitTime) {
                            def status = sh(script: "aws ec2 describe-instance-status --instance-ids ${instanceId} --query 'InstanceStatuses[0].{InstanceState:InstanceState.Name,SystemStatus:SystemStatus.Status,InstanceStatus:InstanceStatus.Status}' --output json", returnStdout: true)
                            // Debug output to check status received
                            echo "Status for instance ${instanceId}: ${status}"
                            // Check if the status is empty
                            if (!status || status.trim() == 'null'){
                                echo "Instance ${instanceId} is still initializing or not available."
                            } else if (status && status != 'null') {
                                def instanceStatus = new groovy.json.JsonSlurper().parseText(status) // Use JsonSlurper for parsing
                                // Check if instance is running and both system and instance statuses are ok
                                if (instanceStatus && instanceStatus.InstanceState && instanceStatus.InstanceState == 'running' && instanceStatus.SystemStatus == 'ok' && instanceStatus.InstanceStatus == 'ok') {
                                    echo " expected states met"
                                    return true // Instance is operational
                                }
                            } 
                            sleep(checkInterval) // Wait before checking again
                            waited += checkInterval // Increment waited time
                        }
                        error "Timeout: Instance ${instanceId} is not operational after ${maxWaitTime} seconds."
                    }
   
   
                   // Function to wait until all specified instances are running
                    def waitForInstancesToStart = { ids, maxWaitTime = 600, checkInterval = 15 ->
                        def waited = 0
                        while (waited < maxWaitTime) {
                            def allOperational = true // Flag to check if all instances are operational
                            for (id in ids) {
                                if (!isInstanceOperational(id,300,15)) {
                                   allOperational = false // If any instance is not operational, set the flag to false
                                   echo "Instance ${instanceId} did not start successfully."
                                }
                            }
                            if (allOperational) {
                                return true // All instances are operational
                            }
                            sleep(checkInterval) // Wait before checking again
                             waited += checkInterval
                        }
                        error "Timeout: Not all instances are started after ${maxWaitTime} seconds."
                    }

                    // Start all first instances of Pega Admin servers simultaneously
                    def firstInstancesToStart = pegaStartAdminservers.collect { it[0] } // First instance IDs
                    echo "Starting the following first Pega Admin instances: ${firstInstancesToStart.join(', ')}"
                    sh "aws ec2 start-instances --instance-ids ${firstInstancesToStart.join(' ')}"
            
                    // Wait for all first instances to be fully operational
                    waitForInstancesToStart(firstInstancesToStart,,600, 15)

                    // Human intervention after confirming first instances
                    input(message: "Check all first Pega Admin instances for all environments and confirm they are operational before proceeding.")

                    // Start second instances if they exist
                    def secondInstancesToStart = pegaStartAdminservers.collect { it.size() > 1 ? it[1] : null }.findAll { it != null }
                    if (secondInstancesToStart) {
                        echo "Starting the following second Pega Admin instances: ${secondInstancesToStart.join(', ')}"
                         sh "aws ec2 start-instances --instance-ids ${secondInstancesToStart.join(' ')}"

                        // Wait for all second instances to be fully operational
                        waitForInstancesToStart(secondInstancesToStart,,600, 15)

                        // Human intervention after confirming second instances
                        input(message: "Check all second Pega Admin instances for all environments and confirm they are operational before proceeding.")
                    }

                    // Start third instances if they exist
                    def thirdInstancesToStart = pegaStartAdminservers.collect { it.size() > 2 ? it[2] : null }.findAll { it != null }
                    if (thirdInstancesToStart) {
                        echo "Starting the following third Pega Admin instances: ${thirdInstancesToStart.join(', ')}"
                        sh "aws ec2 start-instances --instance-ids ${thirdInstancesToStart.join(' ')}"

                        // Wait for all third instances to be fully operational
                        waitForInstancesToStart(thirdInstancesToStart,,600, 15)

                        // Human intervention after confirming third instances
                        input(message: "Check all third Pega Admin instances for all environments and confirm they are operational before proceeding.")
                    }
                 }
             }
        }

        stage('Start Linux Instances') {
            when {
                expression { params.Platform == 'Linux' || params.Platform == 'All' }
            }
            steps {
                script {
                    echo 'Starting Linux Instances...'
                    def linuxInstances = [
                        'i-06a6e3bedfc7e489c',
                        'i-0cf6387c11543434b',
                        'i-0fd5ac3199e8d90c6',
                        'i-0fe398d756a7674d5',
                        'i-07627036355757a91',
                        'i-0761d61e6bde41800',
                        'i-0eb696d2e783b308d',
                        'i-046fd7ae38db5cc02',
                        'i-0bfc2f1385aa6359a',
                        'i-0d95ef8470e999593',
                        'i-0b00f288853c45601',
                        'i-0cd49ce4c628a79da',
                        'i-01b219308b776d8c9',
                        'i-09e022c9f9922f17e',
                        'i-08e44cbe5f2726e69',
                        'i-041559ad9860a0a66',
                        'i-014bd77e3a204255d',
                        'i-09cf5898b393e8ef2',
                        'i-0a126c66fc4d2c23d',
                        'i-0592feca136527713',
                        'i-0801f7d1f11144c3d',
                        'i-011dbf677b83cb4af',
                        'i-0729f9e672c51e2c8',
                        'i-004ca4f23ea69fbd0',
                        'i-0915e6a70c88170bb',
                        'i-078874a30cf0f048e',
                        'i-0f4871c3881d29215',
                        'i-026b0179d602903cd',
                        'i-07cb8ba0fdffbbb8b',
                        'i-0933fe6d03daae3e3',
                        'i-02ef0d40468629edc',
                        'i-059de1e7893df8270',
                        'i-0d4c882bd70f975ee',
                        'i-03da1f9ed98ac198a',
                        'i-030440635b4b39eed',
                        'i-017d38ae484b7971f',
                        'i-08bf7a06fd200a084',
                        'i-0cdea2ed843caaddb',
                        'i-07741514f61487741'] // Define Linux instance IDs
                    // Function to check if instances are running
                    def areInstancesRunning = { ids ->
                        def state = sh(script: "aws ec2 describe-instances --instance-ids ${ids.join(' ')} --query 'Reservations[].Instances[].State.Name' --output text", returnStdout: true).trim()
                    return state.split('\n').every { it == 'running' }
                    }
                     // Function to wait until all specified instances are running
                    def waitForInstancesToStart = { ids, maxWaitTime = 900, checkInterval = 15 ->
                        def waited = 0
                        while (waited < maxWaitTime) {
                            def runningInstances = ids.findAll { areInstancesRunning([it]) } // Get running instances
                            echo "Currently running instances: ${runningInstances.join(', ')}"
                            if (runningInstances.size() == ids.size()) {
                                return true // All instances are operational
                            }
                            sleep(checkInterval) // Wait before checking again
                            waited += checkInterval
                         }
                        error "Timeout: Not all instances are started after ${maxWaitTime} seconds."
                    }
                    echo "Starting the following Windows instances: ${linuxInstances.join(', ')}"

                    sh "aws ec2 start-instances --instance-ids ${linuxInstances.join(' ')}"
                    waitForInstancesToStart(linuxInstances,600, 15) // Ensure all instances are fully operational
                }
            }
        }
        
        stage('Start Windows Instances') {
            when {
                expression { params.Platform == 'Windows' || params.Platform == 'All' }
            }
            steps {
                script {
                    echo 'Starting Windows Instances...'
                    def windowsInstances = [
                        'i-0915fb70e408f60e4',
                        'i-06c8e9966e87a5935',
                        'i-0b71f0bd670834b9d',
                        'i-0ca21ef9a2270d55d',
                        'i-0df9a19ca3538cda8',
                        'i-068a4bc409cd40e06',
                        'i-01616e32d7f17fe1b',
                        'i-09813645748b96018',
                        'i-0c0e62068149e356b',
                        'i-0f8f5e0073f5c4f4e',
                        'i-0461a1eac6cc16150',
                        'i-0239bae9abfc82d9f',
                        'i-00385a16def4a33da',
                        'i-01fe7afc21afed5af',
                        'i-05c6b1925a396feea'] // Define Windows instance IDs
                     // Define Windows instance IDs
                    // Function to check if an instance is operational
                    def isInstanceOperational = { instanceId, maxWaitTime = 300, checkInterval = 15 ->
                        def waited = 0
                        while (waited < maxWaitTime) {
                            def status = sh(script: "aws ec2 describe-instance-status --instance-ids ${instanceId} --query 'InstanceStatuses[0].{InstanceState:InstanceState.Name,SystemStatus:SystemStatus.Status,InstanceStatus:InstanceStatus.Status}' --output json", returnStdout: true)
                            // Debug output to check status received
                            echo "Status for instance ${instanceId}: ${status}"
                            // Check if the status is empty
                            if (!status || status.trim() == 'null'){
                                echo "Instance ${instanceId} is still initializing or not available."
                            } else if (status && status != 'null') {
                                def instanceStatus = new groovy.json.JsonSlurper().parseText(status) // Use JsonSlurper for parsing
                                // Check if instance is running and both system and instance statuses are ok
                                if (instanceStatus && instanceStatus.InstanceState && instanceStatus.InstanceState == 'running' && instanceStatus.SystemStatus == 'ok' && instanceStatus.InstanceStatus == 'ok') {
                                    echo " expected states met"
                                    return true // Instance is operational
                                }
                            } 
                            sleep(checkInterval) // Wait before checking again
                            waited += checkInterval // Increment waited time
                        }
                        error "Timeout: Instance ${instanceId} is not operational after ${maxWaitTime} seconds."
                    }
                    // Function to wait until all specified instances are running
                    def waitForInstancesToStart = { ids, maxWaitTime = 600, checkInterval = 15 ->
                        def waited = 0
                        while (waited < maxWaitTime) {
                            def allOperational = true // Flag to check if all instances are operational
                            for (id in ids) {
                                if (!isInstanceOperational(id,300,15)) {
                                   allOperational = false // If any instance is not operational, set the flag to false
                                   echo "Instance ${instanceId} did not start successfully."
                                }
                            }
                            if (allOperational) {
                                return true // All instances are operational
                            }
                            sleep(checkInterval) // Wait before checking again
                             waited += checkInterval
                        }
                        error "Timeout: Not all instances are started after ${maxWaitTime} seconds."
                    }
                    echo "Starting the following Windows instances: ${windowsInstances.join(', ')}"
                    sh "aws ec2 start-instances --instance-ids ${windowsInstances.join(' ')}"
                    waitForInstancesToStart(windowsInstances, 600, 15) // Ensure all instances are fully operational
                    // Confirm all instances are running
                    echo "All Windows instances are now running."
                }
            }
        }
    }
}